#!/usr/bin/env python

# AUTHOR: Kunal Jha - Anna Mikhailova

# --------------------------------------------------------------------------------------------------------------------------------------------------
# import of relevant python modules and libraries
import rospy
import roslib
import tf
import re
import numpy as np
import math
from tf.transformations import euler_from_quaternion
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Twist, PointStamped # message type for cmd_vel
from wolfpack.msg import CoordArray, FloatList, calcWays

roslib.load_manifest("wolfpack")

# topic constants
TGT_TOPIC = "/target"
DEFAULT_CMD_VEL_TOPIC = "/cmd_vel"
DEFAULT_ODOM_TOPIC = "/odom"
DEFAULT_BASE_LINK = "/base_link"
DEFAULT_PATROL_NAME = "/patrol"
DEFAULT_DISCOVERED_NAME = "/foundT"
OBST_TOPIC = "/obstacle_topic"

# constants
FREQUENCY = 10 #Hz.
TGT_RANGE = 1.5 # range within which patrollers actually register target's position and commence flocking behaviour
RADIUS = 2 # radius for surrounding behaviour
ANGULAR_VELOCITY = math.pi/4  # rads/sec
LINEAR_VELOCITY = 0.1 # m/s
VELOCITY_SCALE = 0.2

# parameters
NUM_BOTS = rospy.get_param("num_bots", 3)

# --------------------------------------------------------------------------------------------------------------------------------------------------
# SOME HELPER METHODS

# helper function to find the euclidean distance between two points
def euclid_dist(x1, y1, x2, y2):
    return ((x1-x2)**2 + (y1-y2)**2)**0.5

# helper functions to find the angle between current orientation and main coordinate
def unit_vector(vector):
    return vector / np.linalg.norm(vector)

def angle_between(v1, v2):
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))

# --------------------------------------------------------------------------------------------------------------------------------------------------
class Patroller:
    def __init__(self, robot_name, numRobots, initX, initY):
        # instance variables
        self.patroller_pose = Pose()
        self.target_pose = Pose()
        self.target_loc = None
        self.found_target = False
        self.patrol_path = []
        self.robot_loc = None 
        self.robot_name = robot_name
        self.numRobots = numRobots
        self.initial_loc = (initX, initY)
        self.rate = rospy.Rate(FREQUENCY)

        self.obstacles = CoordArray()

        # initializing _cmd_vel_pub and target discovery publisher
        self._cmd_vel_pub = rospy.Publisher("/" + self.robot_name + DEFAULT_CMD_VEL_TOPIC, Twist, queue_size=1)
        self.found_target_pub = rospy.Publisher(DEFAULT_DISCOVERED_NAME, calcWays, queue_size=1)

        # initializing patrol subscriber, target subscriber, and target discovery subscriber, and obstacles subscriber
        self.patrol_sub = rospy.Subscriber("/" + self.robot_name + DEFAULT_PATROL_NAME, CoordArray, self.patrol_cb)
        self.target_sub = rospy.Subscriber(TGT_TOPIC, Pose, self.target_cb)
        self.found_target_sub = rospy.Subscriber(DEFAULT_DISCOVERED_NAME, calcWays, self.found_target_cb)
        self.obstacles_sub = rospy.Subscriber(OBST_TOPIC, CoordArray, self._obst_callback, queue_size=1)

        # initializing TF Listener
        self.listener = tf.TransformListener()

# --------------------------------------------------------------------------------------------------------------------------------------------------
# CALL BACK METHODS
# --------------------------------------------------------------------------------------------------------------------------------------------------
    # Purpose: Sends a binary message if target is found
    def found_target_cb(self, msg):
        self.found_target = msg.calculate == 1

    # Purpose: retrieve and store obstacles in an instance variable that we access for the visibility test
    def _obst_callback(self, msg):
        self.obstacles = msg

    # Purpose: Stores the target's location in an (x, y) tuple
    def target_cb(self, msg):

        self.target_pose = msg
        self.target_loc = (msg.position.x, msg.position.y)
        self.rate.sleep()

    # Purpose: calculates the patrol path?? what does this method do??
    def patrol_cb(self, msg):
        self.patrol_path = [] ###~~### DO WE NEED THIS HERE? INITIALIZED IN __init__ METHOD
        path = []
        self.rate.sleep()
        for coords in msg.coords:  # we have FloatLists here
            target = coords.elements
            path.append(tuple(target))
        startIdx = path.index(self.initial_loc)
        res = path[startIdx:] + path[:startIdx]
        self.patrol_path = res  # doing this in case the patrol function is called before callback finishes

    # Purpose: transforms the waypoint from the robot's to the world's reference frame??
    def get_transformed_point(self, waypoint):
        waypoint_stamped = PointStamped() # initializing as a new PointStamped message
        waypoint_stamped.header.frame_id = 'world' # specify that is for the world frame

        waypoint_stamped.point.x, waypoint_stamped.point.y = waypoint[0], waypoint[1] # populate the x and y coordinates
        return self.listener.transformPoint(self.robot_name + DEFAULT_BASE_LINK, waypoint_stamped) # return the transformed point


# --------------------------------------------------------------------------------------------------------------------------------------------------
# WOLFPACK/FLOCKING BEHAVIOUR METHODS -- NEED TO COMMENT THIS!!!!!
# --------------------------------------------------------------------------------------------------------------------------------------------------
    def surround(self):
        self.listener.waitForTransform( "world", self.robot_name + "/base_link", rospy.Time(0), rospy.Duration(4.0))

        # get the current transform and rotation matrices from tf listener
        (trans, rot) = self.listener.lookupTransform("world", self.robot_name + "/base_link",  rospy.Time(0))
        curr = (trans[0], trans[1])
        target_loc_point = self.get_transformed_point(self.target_loc)
        target_loc = (target_loc_point.point.x, target_loc_point.point.y)

        distance_from_target = euclid_dist(0, 0, target_loc[0], target_loc[1])
        distance_to_radius = distance_from_target - RADIUS  # stay TGT_RANGE away
        # get velocity for moving towards target
        angToTarget = math.atan2(target_loc[1], target_loc[0])
        xRadius = distance_to_radius * math.cos(angToTarget)
        yRadius = distance_to_radius * math.sin(angToTarget)

        if self.robot_name == "robot_2":
            print("Robot 2 surrounding:")
            print("Robot 2's location:")
            print(curr)
            print("Target's location:")
            print(self.target_loc)
            print("Robot 2's distance from target:")
            print(distance_from_target)
            print("Angle from target to robot:")
            print(angToTarget)
            print("X and Y distance from safe zone boundary:")
            print((xRadius, yRadius))


        avgX, avgY = 0, 0  # coordinate of average robots
        numRobotsInRange = 0
        for i in range(self.numRobots):
            otherRobotName = "robot_" + str(i)
            if otherRobotName != self.robot_name:
                self.listener.waitForTransform( "world", otherRobotName+ "/base_link", rospy.Time(0), rospy.Duration(4.0))
                # get the other transform and rotation matrices from tf listener
                (other_trans, rot) = self.listener.lookupTransform("world", otherRobotName + "/base_link",  rospy.Time(0))
                other_loc_Point = self.get_transformed_point((other_trans[0], other_trans[1]))
                other_loc = (other_loc_Point.point.x, other_loc_Point.point.y)
                # find locations of other robots in range
                if (euclid_dist(other_loc[0], other_loc[1], target_loc[0], target_loc[1]) <= RADIUS) and (distance_from_target <= RADIUS):
                    avgX += other_loc[0]
                    avgY += other_loc[1]
                    numRobotsInRange += 1
        if numRobotsInRange != 0:  # compute the center of all the robots in the average
            avgX /= numRobotsInRange
            avgY /= numRobotsInRange

        # coordinates to move away from average of robots in center
        separateX = -avgX
        separateY = -avgY
        separateDist = (separateX**2 + separateY**2)**0.5

        # calculate weights for combining action
        separateWeight = 0.5
        if (separateDist + distance_to_radius) != 0:
            separateWeight = separateDist / (separateDist + distance_to_radius)
        followerWeight = 1 - separateWeight

        # calculate joint movement coords and angle
        jointX = xRadius * followerWeight + separateX * separateWeight
        jointY = yRadius * followerWeight + separateY * separateWeight
        distanceToJoint = (jointX**2 + jointY**2)**0.5
        angleToJoint = math.atan2(jointY, jointX)
        clockwise = angleToJoint < 0
        self.rotate_in_place(angleToJoint, clockwise)
        self.move_forward(min(0.1, distanceToJoint))

        self.rate.sleep()

    #IS THIS THE WOLFPACK PATROL METHOD?
    def patrol(self):
        if len(self.patrol_path) > 0:  # non empty patrol path
            # print(self.patrol_path)
            for target in self.patrol_path:
                self.listener.waitForTransform("world", self.robot_name + "/base_link", rospy.Time(0), rospy.Duration(4.0))
                # get the transform and rotation matrices from tf listener
                (trans, rot) = self.listener.lookupTransform("world", self.robot_name + "/base_link",  rospy.Time(0))

                print("Robot perceived location in world frame:")
                print((trans[0], trans[1]))

                self.robot_loc = (0, 0)  # making calculations from robot's perspective
                print("Target robot wants to go to from world frame: ")
                print(target)
                coords = self.get_transformed_point(target)

                coords = [coords.point.x, coords.point.y]
                print("Target robot wants to go to from robot frame: ")
                print(coords)




                dist = euclid_dist(coords[0], coords[1], 0, 0)

                angle = math.atan2(coords[1], coords[0])

                if angle * -1 >= 0:
                    clockwise = True
                else:
                    clockwise = False

                self.rotate_in_place(angle, clockwise)  # move
                self.move_forward(dist)  # move
                self.rate.sleep()


    # Method to retrive and return the current position of the patroller with respect to the world frame
    def retrieve_pose(self):
        patroller_pose = Pose() # initialize patroller position

        now = rospy.Time(0)
        self.listener.waitForTransform("world", self.bot_name + "/odom", now, rospy.Duration(4.0))

        # get the transform and rotation matrices from tf listener
        (trans, rot) = self.listener.lookupTransform("world", self.bot_name + "/odom", now)

        # populate the patroller position
        patroller_pose.position.x, patroller_pose.position.y = trans[0], trans[1]

        return patroller_pose

    # Purpose: method that tests if the direct line of visibility from the patroller to the target is clear of obstacles
    # Returns: a boolean true, if there is clear visibility and false if there is an obstacle
    # Proposed run scheme: something like, "while patroller.visibility_test() returns false, keep moving along, run patroller.visibility_test()"
    def visibility_test(self):
        self.patroller_pose = self.retrieve_pose() # populate the current position of the patroller
        visible_x_cords = []
        visible_y_cords = []

        no_obstacle = True

        for x in range(self.patroller_pose.position.x, self.target_pose.position.x):
            visible_x_cords.add(x) # add all of the x coordinates to check to a list

        for y in range(self.patroller_pose.position.y, self.target_pose.position.y):
            visible_y_cords.add(y) # add all of the y coordinates to check to a list

        for i in range(len(visible_x_cords) - 1): # loop through all of the visibile x's
            for obst in self.obstacles: # loop through all of the obstacles
                if obst[0] == visible_x_cords[i]: # if the visible x is in the obstacle
                    if math.floor(visible_y_cords[i]) == obst[1]: # if bottom of the obstacle is the floor of the corresponding y
                        no_obstacle = False
                        break

        # same thing for the vertical walls
        for j in range(len(visible_y_cords) - 1):
            for obst in self.obstacles:
                if obst[1] == visible_y_cords[j]:
                    if math.floor(visible_x_cords[j]) == obst[0]:
                        no_obstacle = False
                        break
        
        return no_obstacle # returns true if there are no obstacles between the patroller and target, false otherwise

        ### ADJUST BEHAVIOUR OF THE ROBOT ACCORDING TO THE VISIBILITY TEST

        #### PSUEDOCODE FOR THE REST OF IT BECAUSE I AM TIRED, WILL FINISH UP LATER -- ALSO WE NEED AN INSTANCE VARIABLE (naming it M for now) THAT STORES THE BOUNDARIES (OUTLINES) OF THE OBSTACLES
        # for every x in visible_x_cords:
        #   if x in M:
        #       if floor[corresponding y of the x in visible_x_cords] == bottom of the obstacle /// use indices to loop through to be able to do this:
        #           no_obstacle = False
        #           break
        # for every y in visible_y_cords:
        #   if y in M:
        #       if floor[corresponding x of the y in visible_y_cords] == left of the obstacle /// use indices to loop through to be able to do this:
        #           no_obstacle = False
        #           break

        ### DONT MIND THIS, NEED TO FINISH IT OFF BUT MY BRAIN IS FRIED


# --------------------------------------------------------------------------------------------------------------------------------------------------
# MOVEMENT METHODS -- modelled on SimpleMotion
# --------------------------------------------------------------------------------------------------------------------------------------------------
    # Purpose: move forward the robot for a given distance
    # Parameters: self, distance
    def move_forward(self, distance):
        # Rate at which to operate the while loop.
        rate = rospy.Rate(FREQUENCY)

        # Setting velocities.
        twist_msg = Twist()
        twist_msg.linear.x = LINEAR_VELOCITY
        start_time = rospy.get_rostime()
        duration = rospy.Duration(distance/twist_msg.linear.x)

        # Loop.
        while not rospy.is_shutdown():
            # Check if traveled of given distance based on time.
            if rospy.get_rostime() - start_time >= duration:
                break

            # Publish message.
            self._cmd_vel_pub.publish(twist_msg)

            # Sleep to keep the set publishing frequency.
            rate.sleep()

        # Traveled the required distance, stop.
        self.stop()


    # Purpose: rotate in place counterclockwise (unless otherwise specified), based on fixed velocity
    # Parameters: rotation angle
    def rotate_in_place(self, rotation_angle, clockwise):
        twist_msg = Twist()
        rotation_angle = abs(rotation_angle)
        twist_msg.angular.z = ANGULAR_VELOCITY
        duration = rotation_angle / twist_msg.angular.z
        if clockwise:
            twist_msg.angular.z = -twist_msg.angular.z

        start_time = rospy.get_rostime()
        rate = rospy.Rate(FREQUENCY)

        while not rospy.is_shutdown():
            if rospy.get_rostime() - start_time >= rospy.Duration(duration):  # Check if done
                break

            self._cmd_vel_pub.publish(twist_msg)  # Publish message.
            rate.sleep()  # Sleep to keep the set frequency.

        self.stop()  # Rotated the required angle, stop.


    # Purpose: stops bot movement
    # Parameters: self
    def stop(self):
        twist_msg = Twist()
        self._cmd_vel_pub.publish(twist_msg)


# --------------------------------------------------------------------------------------------------------------------------------------------------
# MAIN METHOD
# --------------------------------------------------------------------------------------------------------------------------------------------------
def main():
    numRobots = rospy.get_param("/numRobots")
    robot_name = rospy.get_param("robot_name")  # get relative param for name
    initialX = rospy.get_param("x_pos")
    initialY = rospy.get_param("y_pos")

    print(robot_name)
    patroller = Patroller(robot_name, numRobots, initialX, initialY)
    print("initialized patroller")

    # try:
    rate = rospy.Rate(FREQUENCY)
    while not rospy.is_shutdown():
        # if patroller.target_loc is not None:
        #     patroller.surround()
        # else:

        patroller.patrol()
        rate.sleep()


if __name__ == "__main__":
    # 1st. initialization of node.
    rospy.init_node("patroller")
    # Sleep for a few seconds to wait for the registration.
    print("sleeping")
    rospy.sleep(7)
    main()
