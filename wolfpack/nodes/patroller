#!/usr/bin/env python

# AUTHOR: Kunal Jha - Anna Mikhailova

# --------------------------------------------------------------------------------------------------------------------------------------------------
# import of relevant python modules and libraries
import rospy
import roslib
import tf
import re
import numpy as np
import math
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Twist, PointStamped # message type for cmd_vel
from wolfpack.msg import CoordArray, FloatList, calcWays

roslib.load_manifest("wolfpack")

# topic constants
TGT_TOPIC = "/target"
DEFAULT_CMD_VEL_TOPIC = "/cmd_vel"
DEFAULT_ODOM_TOPIC = "/odom"
DEFAULT_BASE_LINK = "/base_link"
DEFAULT_PATROL_NAME = "/patrol"
DEFAULT_DISCOVERED_NAME = "/foundT"

# constants
FREQUENCY = 10 #Hz.
TGT_RANGE = 2 # range within which patrollers actually register target's position and commence flocking behaviour
RADIUS = 5 # radius for surrounding behaviour
ANGULAR_VELOCITY = math.pi/4  # rads/sec
LINEAR_VELOCITY = 0.1 # m/s
VELOCITY_SCALE = 0.1

# parameters
NUM_BOTS = rospy.get_param("num_bots", 3)

# --------------------------------------------------------------------------------------------------------------------------------------------------
# SOME HELPER METHODS

# helper function to find the euclidean distance between two points
def euclid_dist(x1, y1, x2, y2):
    return ((x1-x2)**2 + (y1-y2)**2)**0.5

# helper functions to find the angle between current orientation and main coordinate
def unit_vector(vector):
    return vector / np.linalg.norm(vector)

def angle_between(v1, v2):
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))

# --------------------------------------------------------------------------------------------------------------------------------------------------
class Patroller:
    def __init__(self, robot_name, numRobots):

        # initializing _cmd_vel_pub and target discovery publisher
        self._cmd_vel_pub = rospy.Publisher("/" + self.robot_name + DEFAULT_CMD_VEL_TOPIC, Twist, queue_size=1)
        self.found_target_pub = rospy.Publisher(DEFAULT_DISCOVERED_NAME, calcWays, queue_size=1)

        # initializing patrol subscriber, target subscriber, and target discovery subscriber
        self.patrol_sub = rospy.Subscriber("/" + self.robot_name + DEFAULT_PATROL_NAME, CoordArray, self.patrol_cb)
        self.target_sub = rospy.Subscriber(TGT_TOPIC, Pose, self.target_cb)
        self.found_target_sub = rospy.Subscriber(DEFAULT_DISCOVERED_NAME, calcWays, self.found_target_cb)

        # initializing TF Listener
        self.listener = tf.TransformListener()

        # instance variables
        self.patroller_pose = Pose()
        self.target_pose = Pose()
        self.target_loc = None
        self.found_target = False
        self.patrol_path = []
        self.robot_loc = None ###~~### WHERE IS THIS POPULATED? AND WHAT IS IT POPULATED WITH? IS THIS RELIABLY UPDATED??
        self.robot_name = robot_name
        self.numRobots = numRobots
        self.rate = rospy.Rate(FREQUENCY)                

# --------------------------------------------------------------------------------------------------------------------------------------------------
# CALL BACK METHODS
# --------------------------------------------------------------------------------------------------------------------------------------------------
    # Purpose: Sends a binary message if target is found
    def found_target_cb(self, msg):
        self.found_target = msg.calculate == 1

    # Purpose: Stores the target's location in an (x, y) tuple
    def target_cb(self, msg):
        print(msg)
        self.target_pose = msg
        self.target_loc = (msg.position.x, msg.position.y)
        self.rate.sleep()

    # Purpose: calculates the patrol path?? what does this method do??
    def patrol_cb(self, msg):
        self.patrol_path = [] ###~~### DO WE NEED THIS HERE? INITIALIZED IN __init__ METHOD
        path = []
        self.rate.sleep()
        for coords in msg.coords:  # we have FloatLists here
            target = coords.elements
            path.append(target)
        self.patrol_path = path  # doing this in case the patrol function is called before callback finishes

    # Purpose: transforms the waypoint from the robot's to the world's reference frame??
    def get_transformed_point(self, waypoint):
        waypoint_stamped = PointStamped() # initializing as a new PointStamped message
        waypoint_stamped.header.frame_id = 'world' # specify that is for the world frame

        waypoint_stamped.point.x, waypoint_stamped.point.y = waypoint[0], waypoint[1] # populate the x and y coordinates 
        return self.listener.transformPoint(self.robot_name + DEFAULT_BASE_LINK, waypoint_stamped) # return the transformed point


# --------------------------------------------------------------------------------------------------------------------------------------------------
# WOLFPACK/FLOCKGIN BEHAVIOUR METHODS -- NEED TO COMMENT THIS!!!!!
# --------------------------------------------------------------------------------------------------------------------------------------------------  
    def surround(self):
        self.listener.waitForTransform( "world", self.robot_name + "/base_link", rospy.Time(0), rospy.Duration(4.0))

        # get the current transform and rotation matrices from tf listener
        (trans, rot) = self.listener.lookupTransform("world", self.robot_name + "/base_link",  rospy.Time(0))
        curr = (trans[0], trans[1])
        distance_from_target = euclid_dist(curr[0], curr[1], self.target_loc[0], self.target_loc[1])
        distance_to_radius = distance_from_target - TGT_RANGE  # stay TGT_RANGE away
        # get velocity for moving towards target
        angToTarget = math.atan2(self.target_loc[1] - curr[1], self.target_loc[0] - curr[0])
        xRadius = distance_to_radius * math.cos(angToTarget)
        yRadius = distance_to_radius * math.cos(angToTarget)
        vxToRadius = xRadius - curr[0]
        vyToRadius = yRadius - curr[0]
        if distance_to_radius != 0:
            vxToRadius /= distance_to_radius
            vyToRadius /= distance_to_radius


        avgX, avgY = 0, 0  # coordinate of average robots
        numRobotsInRange = 0
        for i in range(self.numRobots):
            otherRobotName = "robot_" + str(i)
            if otherRobotName != self.robot_name:
                self.listener.waitForTransform( "world", otherRobotName+ "/base_link", rospy.Time(0), rospy.Duration(4.0))
                # get the other transform and rotation matrices from tf listener
                (other_trans, rot) = self.listener.lookupTransform("world", otherRobotName + "/base_link",  rospy.Time(0))
                # find locations of other robots in range
                if (euclid_dist(other_trans[0], other_trans[1], self.target_loc[0], self.target_loc[1]) <= TGT_RANGE):
                    avgX += other_trans[0]
                    avgY += other_trans[1]
                    numRobotsInRange += 1
        if numRobotsInRange != 0:
            avgX /= numRobotsInRange
            avgY /= numRobotsInRange
        # get velocity for moving away from other robots
        vxToCenter = avgX - curr[0]
        vyToCenter = avgY - curr[1]
        distToCenter = euclid_dist(avgX, avgY, curr[0], curr[1])
        if euclid_dist != 0:
            vxToCenter /= distToCenter
            vyToCenter /= distToCenter

        vx = vxToRadius - vxToCenter
        vy = vyToRadius - vyToCenter

        angle = math.atan2(vy, vx)
        if angle < 0:
            clockwise = True
        else:
            clockwise = False
        self.rotate_in_place(angle, clockwise)
        distToTravel = (vx**2 + vy**2) ** 0.5
        self.move_forward(min(1, distToTravel))
        self.rotate_in_place(angle, not clockwise)
        self.rate.sleep()

    #IS THIS THE WOLFPACK PATROL METHOD?
    def patrol(self):
        if len(self.patrol_path) > 0:  # non empty patrol path
            for target in self.patrol_path:
                self.robot_loc = (0, 0)  # making calculations from robot's perspective

                coords = self.get_transformed_point(target)
                coords = [coords.point.x, coords.point.y]


                vx, vy = coords[0] - self.robot_loc[0], coords[1] - self.robot_loc[1]
                dist = euclid_dist(coords[0], coords[1], 0, 0)
                # dist = euclid_dist(coords[0], coords[1], self.robot_loc[0], self.robot_loc[1])

                # normalize velocity
                if dist != 0:
                    vx /= dist
                    vy /= dist
                # scale velocity
                vx *= VELOCITY_SCALE
                vy *= VELOCITY_SCALE

                angle = math.atan2(vy, vx)

                if angle * -1 >= 0:
                    clockwise = True
                else:
                    clockwise = False

                self.rotate_in_place(angle, clockwise)  # move
                self.move_forward(dist)  # move
                self.rotate_in_place(angle, not clockwise) # rotating back to original face
                self.rate.sleep()


    # Method to retrive and return the current position of the patroller with respect to the world frame
    def retrieve_pose(self):
        patroller_pose = Pose() # initialize patroller position

        now = rospy.Time(0)
        self.listener.waitForTransform("world", self.bot_name + "/odom", now, rospy.Duration(4.0))

        # get the transform and rotation matrices from tf listener
        (trans, rot) = self.listener.lookupTransform("world", self.bot_name + "/odom", now)

        # populate the patroller position
        patroller_pose.position.x, patroller_pose.position.y = trans[0], trans[1]
    
        return patroller_pose

    # Purpose: method that tests if the direct line of visibility from the patroller to the target is clear of obstacles
    # Returns: a boolean true, if there is clear visibility and false if there is an obstacle
    # Proposed run scheme: something like, "while patroller.visibility_test() returns false, keep moving along, run patroller.visibility_test()"
    def visibility_test(self):
        self.patroller_pose = self.retrieve_pose() # populate the current position of the patroller
        visible_x_cords = []
        visible_y_cords = []

        no_obstacle = False

        for x in range(self.patroller_pose.position.x, self.target_pose.position.x):
            visible_x_cords.add(x) # add all of the x coordinates to check to a list

        for y in range(self.patroller_pose.position.y, self.target_pose.position.y):
            visible_y_cords.add(y) # add all of the y coordinates to check to a list

        #### PSUEDOCODE FOR THE REST OF IT BECAUSE I AM TIRED, WILL FINISH UP LATER -- ALSO WE NEED AN INSTANCE VARIABLE (naming it M for now) THAT STORES THE BOUNDARIES (OUTLINES) OF THE OBSTACLES
        # for every x in visible_x_cords:
        #   if x in M:
        #       if floor[corresponding y of the x in visible_x_cords] == bottom of the obstacle /// use indices to loop through to be able to do this:
        #           no_obstacle = False
        #           break
        # for every y in visible_y_cords:
        #   if y in M:
        #       if floor[corresponding x of the y in visible_y_cords] == left of the obstacle /// use indices to loop through to be able to do this:
        #           no_obstacle = False
        #           break
        
        ### DONT MIND THIS, NEED TO FINISH IT OFF BUT MY BRAIN IS FRIED


# --------------------------------------------------------------------------------------------------------------------------------------------------
# MOVEMENT METHODS -- modelled on SimpleMotion
# --------------------------------------------------------------------------------------------------------------------------------------------------
    # Purpose: move forward the robot for a given distance
    # Parameters: self, distance
    def move_forward(self, distance):
        # Rate at which to operate the while loop.
        rate = rospy.Rate(FREQUENCY)

        # Setting velocities.
        twist_msg = Twist()
        twist_msg.linear.x = LINEAR_VELOCITY
        start_time = rospy.get_rostime()
        duration = rospy.Duration(distance/twist_msg.linear.x)

        # Loop.
        while not rospy.is_shutdown():
            # Check if traveled of given distance based on time.
            if rospy.get_rostime() - start_time >= duration:
                break

            # Publish message.
            self._cmd_vel_pub.publish(twist_msg)

            # Sleep to keep the set publishing frequency.
            rate.sleep()

        # Traveled the required distance, stop.
        self.stop()


    # Purpose: rotate in place counterclockwise (unless otherwise specified), based on fixed velocity
    # Parameters: rotation angle
    def rotate_in_place(self, rotation_angle, clockwise):
        twist_msg = Twist()
        rotation_angle = abs(rotation_angle)
        twist_msg.angular.z = ANGULAR_VELOCITY
        duration = rotation_angle / twist_msg.angular.z
        if clockwise:
            twist_msg.angular.z = -twist_msg.angular.z

        start_time = rospy.get_rostime()
        rate = rospy.Rate(FREQUENCY)

        while not rospy.is_shutdown():
            if rospy.get_rostime() - start_time >= rospy.Duration(duration):  # Check if done
                break

            self._cmd_vel_pub.publish(twist_msg)  # Publish message.
            rate.sleep()  # Sleep to keep the set frequency.

        self.stop()  # Rotated the required angle, stop.


    # Purpose: stops bot movement
    # Parameters: self
    def stop(self):
        twist_msg = Twist()
        self._cmd_vel_pub.publish(twist_msg)


# --------------------------------------------------------------------------------------------------------------------------------------------------
# MAIN METHOD
# --------------------------------------------------------------------------------------------------------------------------------------------------
def main():
    numRobots = rospy.get_param("/numRobots")
    robot_name = rospy.get_param("robot_name")  # get relative param for name
    print(robot_name)
    patroller = Patroller(robot_name, numRobots)
    print("initialized patroller")

    # try:
    rate = rospy.Rate(FREQUENCY)
    while not rospy.is_shutdown():
        if patroller.target_loc is not None:
            patroller.surround()
        # patroller.patrol()
        rate.sleep()


if __name__ == "__main__":
    # 1st. initialization of node.
    rospy.init_node("patroller")
    # Sleep for a few seconds to wait for the registration.
    print("sleeping")
    rospy.sleep(7)
    main()
