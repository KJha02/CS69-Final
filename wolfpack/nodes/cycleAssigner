#!/usr/bin/env python
import roslib
roslib.load_manifest('wolfpack')
import random
from random import randint
import rospy
from wolfpack.msg import CoordArray, FloatList, calcWays
import networkx as nx
from networkx.algorithms.tree.mst import minimum_spanning_tree

FREQUENCY = 10

class Assigner:
    def __init__(self, numRobots):
        self.wall_locations = set([])
        # horizontal locations hard coded in
        for wall in [[-4.0, 3.0], [-2.0, -1.0], [-5.0, -4.0], [3.0, 5.0], [5.0, 5.0], [4.0, 0.0], [5.0, 0.0]]:
            self.wall_locations.add(tuple(wall))
            self.wall_locations.add((wall[0]-1, wall[1]))
            self.wall_locations.add((wall[0]+1, wall[1]))
        # vertical locations hard coded in
        for wall in [[-3.0, 2.0], [3.0, -2.0], [3.0, -4.0], [-2.0, -1.0], [-5.0, -3.0]]:
            self.wall_locations.add(tuple(wall))
            self.wall_locations.add((wall[0], wall[1]-1))
            self.wall_locations.add((wall[0], wall[1]+1))


        self.numRobots = numRobots
        self.rate = rospy.Rate(FREQUENCY)

        self.assigned_path = {}
        self.patrol_publishers = {}
        self.full_graphs = {}
        for i in range(self.numRobots):  # assigning default paths
            self.assigned_path[i] = self.makeCycle(i)
            self.patrol_publishers[i] = rospy.Publisher('/robot_' + str(i) + '/patrol', CoordArray, queue_size=1)

    def makeCycle(self, robot_id):
        # restricting robot movement
        if robot_id == 1 or robot_id == 2:
            lower_y = 0
        else:
            lower_y = -6
        if robot_id == 0 or robot_id == 1:
            lower_x = -6
        else:
            lower_x = 0
        upper_x, upper_y = lower_x + 6, lower_y + 6
        lower_y = lower_y / 2
        upper_y = upper_y / 2
        lower_x = lower_x / 2
        upper_x = upper_x / 2
        # building graph
        G = nx.Graph()
        for x in range(lower_x, upper_x):
            for y in range(lower_y, upper_y):
                up = y < upper_y
                down = y > lower_y
                right = x < upper_x
                left = x > lower_x
                # adding neighbors if in bounds and not an obstacle
                if (up):
                    G.add_edge((x,y), (x, y+1), weight=1)
                if (down):
                    G.add_edge((x,y), (x, y-1), weight=1)
                if (left) and (x-1, y):
                    G.add_edge((x,y), (x-1, y), weight=1)
                if (right) and (x+1, y):
                    G.add_edge((x,y), (x+1, y), weight=1)

        mst = minimum_spanning_tree(G)  # get mst from graph using kruskal's algorithm by default

        def smallToBig(x, y):
            return (x // 2, y // 2)

        firstBig = (lower_x, upper_y)
        firstSmall = (firstBig[0] * 2, firstBig[1]*2)
        cycle = []
        curr = firstSmall
        while (curr not in cycle):
            if True:
                cycle.append(curr)
                (x, y) = curr
                isRight = x % 2 == 1
                isBottom = y % 2 == 0
                this_big = smallToBig(x, y)
                if (this_big in mst.adj):  # if we have reached a valid coord
                    if (not isRight and not isBottom):  # top left
                        up_big = (this_big[0], this_big[1] + 1)
                        if (up_big not in mst.adj[this_big]):  # go right, but only if tree isn't up
                            curr = (x+1, y)
                        else:  # go up if tree goes up
                            curr = (x, y+1)
                    elif (isRight and not isBottom):  # top right
                        right_big = (this_big[0] + 1, this_big[1])
                        if (right_big not in mst.adj[this_big]):  # go down only if right isn't coveren't
                            curr = (x, y-1)
                        else:  # go right if tree goes right
                            curr = (x+1, y)
                    elif (isRight and isBottom):  # bottom right
                        down_big = (this_big[0], this_big[1] - 1)
                        if (down_big not in mst.adj[this_big]):  #   # go left if tree doesn't go down
                            curr = (x-1, y)
                        else:  # go down if tree goes down
                            curr = (x, y-1)
                    else:  # bottom right
                        left_big = (this_big[0] - 1, this_big[1])
                        if (left_big not in mst.adj[this_big]):  # go up if tree doesn't go left
                            curr = (x, y+1)
                        else:  # go left if tree goes left
                            curr = (x-1, y)
        return cycle

    def publish_paths(self):
        # publishing default paths
        for i in range(self.numRobots):
            robotPath = CoordArray()
            robotPath.coords = []
            for coord in self.assigned_path[i]:  # getting the robot path as a msg
                coord_list = FloatList()
                coord_list.elements = coord
                coord_list.robot_id = -1  # dummy values
                coord_list.dist = float("inf")  # dummy values
                robotPath.coords.append(coord_list)
            self.patrol_publishers[i].publish(robotPath)  # publish the patrol message

def main():
    numRobots = rospy.get_param("/numRobots")

    assigner = Assigner(numRobots)
    rate = rospy.Rate(FREQUENCY)
    while not rospy.is_shutdown():
        assigner.publish_paths()
        rate.sleep()


if __name__ == "__main__":
    # 1st. initialization of node.
    print("initializing node")
    rospy.init_node("cycleAssigner")
    print("initialized node")
    # Sleep for a few seconds to wait for the registration.
    print("sleeping")
    rospy.sleep(7)
    print("finished sleeping")
    main()
