#!/usr/bin/env python
import roslib
roslib.load_manifest('coordination')
import rospy
import math
import numpy as np
import tf
import geometry_msgs.msg
from geometry_msgs.msg import Twist, PointStamped # message type for cmd_vel
from wolfpack.msg import calcWays, CoordArray, FloatList
from nav_msgs.msg import Odometry
from tf.transformations import euler_from_quaternion


DEFAULT_CMD_VEL_TOPIC = '/cmd_vel'
FREQUENCY = 5
ANGULAR_VELOCITY = math.pi/4 # rad/s
DEFAULT_ODOM_TOPIC = '/odom'
DEFAULT_BASE_LINK = '/base_link'
DEFAULT_PATROL_NAME = '/patrol'
VELOCITY_SCALE = 1

def euclid_dist(x1, y1, x2, y2):
    return ((x1-x2)**2 + (y1-y2)**2)**0.5

# helper functions to find the angle between current orientation and main coordinate
def unit_vector(vector):
    return vector / np.linalg.norm(vector)

def angle_between(v1, v2):
    v1_u = unit_vector(v1)
    v2_u = unit_vector(v2)
    return np.arccos(np.clip(np.dot(v1_u, v2_u), -1.0, 1.0))

class Follower:
    def __init__(self, robot_name):
        self.robot_name = robot_name
        self.rate = rospy.Rate(FREQUENCY)

        self.patrol_path = []
        self.robot_loc = None

        self.cmd_vel_pub = rospy.Publisher("/" + self.robot_name + DEFAULT_CMD_VEL_TOPIC, Twist, queue_size=1)
        self.patrol_sub = rospy.Subscriber("/" + self.robot_name + DEFAULT_PATROL_NAME, CoordArray, self.patrol_cb)
        self.listener = tf.TransformListener()


    def patrol_cb(self, msg):
        self.patrol_path = []
        print(msg)
        path = []
        self.rate.sleep()
        for coords in msg.coords:  # we have FloatLists here
            target = coords.elements
            path.append(target)
        self.patrol_path = path  # doing this incase the patrol function is called before callback finishes

    def get_transformed_point(self, waypoint):
        waypoint_stamped = PointStamped()
        waypoint_stamped.header.frame_id = 'world'
        waypoint_stamped.point.x = waypoint[0]
        waypoint_stamped.point.y = waypoint[1]
        return self.listener.transformPoint(self.robot_name + DEFAULT_BASE_LINK, waypoint_stamped)

    def patrol(self):
        if len(self.patrol_path) > 0:  # non empty patrol path
            print("Found patrol path")
            print(self.patrol_path)
            for target in self.patrol_path:
                coords = self.get_transformed_point(target)
                coords = [coords.point.x, coords.point.y]
                self.robot_loc = (0, 0)  # making calculations from robot's perspective

                vx, vy = coords[0] - self.robot_loc[0], coords[1] - self.robot_loc[1]
                dist = euclid_dist(coords[0], coords[1], 0, 0)

                # normalize velocity
                vx /= dist
                vy /= dist
                # scale velocity
                vx *= VELOCITY_SCALE
                vy *= VELOCITY_SCALE

                if (vx != 0):
                    angle = math.atan(vy/vx)
                else:
                    angle = 0

                if angle * -1 >= 0:
                    clockwise = True
                else:
                    clockwise = False

                self.rotate_in_place(angle, clockwise)  # move
                self.move_forward(dist)  # move
                self.rotate_in_place(angle, not clockwise) # rotating back to original face

                self.rate.sleep()


    def move_forward(self, distance):
        """Function to move_forward for a given distance."""
        # Rate at which to operate the while loop.
        # Setting velocities.
        twist_msg = Twist()
        twist_msg.linear.x = VELOCITY_SCALE
        start_time = rospy.get_rostime()
        duration = rospy.Duration(distance/twist_msg.linear.x)

        # Loop.
        while not rospy.is_shutdown():
            # Check if traveled of given distance based on time.
            if rospy.get_rostime() - start_time >= duration:
                break
            self.cmd_vel_pub.publish(twist_msg)

            # Sleep to keep the set publishing frequency.
            self.rate.sleep()

        # Traveled the required distance, stop.
        self.stop()
    def rotate_in_place(self, rotation_angle, clockwise=False):
        """
        Rotate in place the robot of rotation_angle (rad) based on fixed velocity.
        Assumption: Counterclockwise rotation
        """
        twist_msg = Twist()
        twist_msg.angular.z = ANGULAR_VELOCITY
        rotation_angle = abs(rotation_angle)
        duration = rotation_angle / twist_msg.angular.z
        if clockwise:  # clockwise has the same motion as counterclockwise just in the opposite direction
            twist_msg.angular.z = -twist_msg.angular.z
        start_time = rospy.get_rostime()
        while not rospy.is_shutdown():
            # Check if done
            if rospy.get_rostime() - start_time >= rospy.Duration(duration):
                break

            # Publish message.
            self.cmd_vel_pub.publish(twist_msg)

            # Sleep to keep the set frequency.
            self.rate.sleep()
        # Rotated the required angle, stop.
        self.stop()
    def stop(self):
        """Stop the robot."""
        twist_msg = Twist()
        self.cmd_vel_pub.publish(twist_msg)


def main():
    robot_name = rospy.get_param("robot_name")  # get relative param for name
    print(robot_name)
    follower = Follower(robot_name)
    print("initialized follower")

    # try:
    rate = rospy.Rate(FREQUENCY)
    while not rospy.is_shutdown():
        print("trying to patrol for robot " + robot_name)
        follower.patrol()
        print("finished patrolling for robot " + robot_name)
        rate.sleep()
    # except rospy.ROSInterruptException:
    #     rospy.logerr("ROS node interrupted.")

if __name__ == "__main__":
    # 1st. initialization of node.
    rospy.init_node("follower_agent")
    # Sleep for a few seconds to wait for the registration.
    print("sleeping")
    rospy.sleep(7)
    main()
